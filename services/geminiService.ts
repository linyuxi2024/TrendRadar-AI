import { GoogleGenAI } from "@google/genai";
import { Topic, TrendItem, TrendReport, GroundingSource, Language } from "../types";

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

// Helper to generate a unique ID
const generateId = () => Math.random().toString(36).substr(2, 9);

export const fetchTrends = async (topic: Topic, language: Language): Promise<TrendReport> => {
  const modelId = "gemini-2.5-flash";
  
  let promptContext = "";
  if (topic === Topic.AI) {
    promptContext = `
      Focus Area: 
      1. Latest updates on Large Language Models (LLMs) from INTERNATIONAL providers (e.g., OpenAI, Google, Anthropic, Meta).
      2. Latest updates from CHINESE DOMESTIC providers (e.g., Baidu Ernie/Wenxin, Alibaba Qwen/Tongyi, DeepSeek, Zhipu AI, etc.).
      3. Critical AI industry trends, open-source model breakthroughs, and enterprise implementation cases.
      
      Requirement: Search as broadly as possible without limit on the number of sources, then synthesize and select the Top 10 hottest and most impactful news items.
    `;
  } else {
    promptContext = `
      Focus Area: 
      1. Major platform policy updates (Amazon, TikTok Shop, Temu, SHEIN, AliExpress).
      2. Global logistics and supply chain shifts.
      3. Market trends in key regions (North America, Europe, Southeast Asia).
      4. Compliance and regulatory changes affecting cross-border trade.

      Requirement: Search as broadly as possible without limit on the number of sources, then synthesize and select the Top 10 hottest and most impactful news items.
    `;
  }

  const langInstruction = language === 'zh' 
    ? "Please generate the response in Simplified Chinese." 
    : "Please generate the response in English.";

  const prompt = `
    You are a senior trend analyst. 
    Task: Search extensively for the latest news in "${topic}" from the LAST 7 DAYS.
    ${promptContext}
    
    ${langInstruction}

    Strict Output Format:
    Please provide the output as a structured Markdown list containing exactly the Top 10 items.
    Use the separator "---ITEM_SEPARATOR---" strictly between each trend item.
    Do NOT add any introductory text or conclusion. Start directly with the first item.
    
    Structure for each item:
    ### [Title of the News/Trend]
    **Summary**: [Concise summary of what happened, max 2 sentences]
    **Impact**: [Why this matters to the industry]
    **Key Takeaway**: [One actionable point or insight]
    **Sources**: [Source Title](URL), [Source Title](URL)
    (Requirement: List up to 3 most relevant source URLs found during search. Prioritize Official Websites, Documentation, or Primary Press Releases if available. If more than 3, select the top 3 best sources.)
  `;

  try {
    const response = await ai.models.generateContent({
      model: modelId,
      contents: prompt,
      config: {
        tools: [{ googleSearch: {} }],
      },
    });

    const text = response.text || "";
    
    // Parse the text based on the separator
    const rawItems = text.split("---ITEM_SEPARATOR---").filter(i => i.trim().length > 10);
    
    const items: TrendItem[] = rawItems.map((raw) => {
      const titleMatch = raw.match(/###\s*(.+)/);
      const summaryMatch = raw.match(/\*\*Summary\*\*:\s*(.+)/);
      const impactMatch = raw.match(/\*\*Impact\*\*:\s*(.+)/);
      const takeawayMatch = raw.match(/\*\*Key Takeaway\*\*:\s*(.+)/);
      const sourcesMatch = raw.match(/\*\*Sources\*\*:\s*(.+)/);

      // Extract sources from the markdown text generated by the model
      const sources: GroundingSource[] = [];
      if (sourcesMatch) {
        const sourceLine = sourcesMatch[1];
        // Match standard markdown links [Title](URL)
        const linkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
        let match;
        while ((match = linkRegex.exec(sourceLine)) !== null) {
          if (sources.length < 3) { // Enforce max 3 limit in parsing as a safeguard
             sources.push({
               title: match[1].trim(),
               uri: match[2].trim()
             });
          }
        }
      }

      return {
        id: generateId(),
        title: titleMatch ? titleMatch[1].trim() : "Untitled Trend",
        summary: summaryMatch ? summaryMatch[1].trim() : "No summary available.",
        impact: impactMatch ? impactMatch[1].trim() : "No impact analysis available.",
        takeaway: takeawayMatch ? takeawayMatch[1].trim() : "No takeaway available.",
        sources: sources
      };
    });

    return {
      topic,
      date: new Date().toLocaleDateString(),
      items,
      rawMarkdown: text,
      language
    };

  } catch (error) {
    console.error("Gemini API Error:", error);
    throw new Error("Failed to fetch trends. Please check your API key and try again.");
  }
};